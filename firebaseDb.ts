import { db, auth } from './firebase';
import {
  collection,
  getDocs,
  addDoc,
  updateDoc,
  deleteDoc,
  doc,
  query,
  where,
} from 'firebase/firestore';

// --- Interface Definitions ---
export interface Subtask {
    id: number; // Using timestamp for subtask id is fine as it's nested
    text: string;
    completed: boolean;
}

export interface Task {
    id: string; // Firestore doc ID is string
    userId: string; // To associate tasks with users
    text: string;
    completed: boolean;
    dueDate?: string; // YYYY-MM-DD
    importance?: 'low' | 'medium' | 'high';
    recurring?: {
        frequency: 'daily' | 'weekly' | 'monthly' | 'yearly';
    };
    subtasks?: Subtask[];
}

// Collection reference
const tasksCollection = collection(db, 'tasks');

// --- Productivity Task Functions ---

/**
 * Fetches all tasks from Firestore for the currently authenticated user.
 * Returns an empty array if no user is signed in.
 */
export const getTasks = async (): Promise<Task[]> => {
    const user = auth.currentUser;
    if (!user) {
        console.log("No user is signed in. Returning empty tasks array.");
        return [];
    }

    try {
        const q = query(tasksCollection, where("userId", "==", user.uid));
        const querySnapshot = await getDocs(q);
        const tasks = querySnapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        } as Task));
        return tasks;
    } catch (error) {
        console.error("Error fetching tasks from Firestore:", error);
        throw error;
    }
};

/**
 * The data required to create a new task.
 * `id` is auto-generated by Firestore, and `userId` is added internally.
 */
export type NewTaskData = Omit<Task, 'id' | 'userId'>;

/**
 * Adds a new task to Firestore for the current user.
 * @param taskData The task data to add.
 * @returns The newly created task object, including its new Firestore ID.
 */
export const addTask = async (taskData: NewTaskData): Promise<Task> => {
    const user = auth.currentUser;
    if (!user) {
        throw new Error("User not authenticated. Cannot add task.");
    }
    
    const newTaskData = { ...taskData, userId: user.uid };
    const docRef = await addDoc(tasksCollection, newTaskData);
    
    return {
        id: docRef.id,
        ...newTaskData
    };
};

/**
 * Updates an existing task in Firestore.
 * @param task The complete task object, including its `id`, to update.
 * @returns The updated task object.
 */
export const updateTask = async (task: Task): Promise<Task> => {
    const user = auth.currentUser;
    if (!user) {
        throw new Error("User not authenticated. Cannot update task.");
    }
    if (user.uid !== task.userId) {
        throw new Error("User not authorized to update this task.");
    }
    
    const taskDocRef = doc(db, 'tasks', task.id);
    const { id, ...taskData } = task; // Exclude id from the data being written
    await updateDoc(taskDocRef, taskData);
    return task;
};

/**
 * Deletes a task from Firestore.
 * @param id The ID of the task to delete.
 */
export const deleteTask = async (id: string): Promise<void> => {
    const user = auth.currentUser;
    if (!user) {
        throw new Error("User not authenticated. Cannot delete task.");
    }
    
    // Firestore security rules should enforce that a user can only delete their own tasks.
    const taskDocRef = doc(db, 'tasks', id);
    await deleteDoc(taskDocRef);
};
